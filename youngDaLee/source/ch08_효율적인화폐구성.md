# Part02 주요 알고리즘 이론과 실전 문제
chapter08. 다이나믹 프로그래밍
- 효율적인 화폐 구성

### 문제 이해하기
- N가지 종류 화폐. 화폐들 개수 최소한 이용해서 M원이 되도록 함.
- 사용한 화폐 구성  같지만 순서만 다른 것 같은 경우로 구분함.

### 문제 접근 방법
- 책 코드 참고함...
- 화폐 단위 하나씩 꺼내서 확인함, dp[0]=0으로 둠
- 이번 화폐 단위를 꺼내 i에 저장함. 현재 돈(인덱스) j에서 코인 i를 사용했을 때 값이 존재하면(j-i 인덱스가 존재하면) 지금의 인덱스랑 j-i에서 1을 더한 것 중 작은걸 채택함.
- 마지막까지 돌려서 10001이면 m원이 못 되는 것 -> -1출력.

### 구현 배경 지식
dp

### 문제를 해결한 코드
```python
n, m = map(int, input().split())
money = list(map(int, input().split()))

dp = [10001]*(m+1) # 최댓값으로 dp 채워넣음
dp[0] = 0


for i in money:
    for j in range(i, m+1):
        if dp[j-i] != 10001:
            dp[j] = min(dp[j], dp[j-i]+1)


if dp[m] == 10001:
    print(-1)
else:
    print(dp[m])
```

